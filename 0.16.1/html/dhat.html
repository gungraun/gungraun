<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Heap profiling with DHAT - Iai-Callgrind Guide</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Iai-Callgrind, a high-precision and consistent one-shot benchmarking framework/harness for Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="css/my.css">
        <link rel="stylesheet" href="css/dropdown.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting_help.html"><strong aria-hidden="true">2.</strong> Getting Help</a></li><li class="chapter-item expanded affix "><li class="part-title">Installation</li><li class="chapter-item expanded "><a href="installation/prerequisites.html"><strong aria-hidden="true">3.</strong> Prerequisites</a></li><li class="chapter-item expanded "><a href="installation/iai_callgrind.html"><strong aria-hidden="true">4.</strong> Iai-Callgrind</a></li><li class="chapter-item expanded affix "><li class="part-title">Benchmarks</li><li class="chapter-item expanded "><a href="benchmarks/overview.html"><strong aria-hidden="true">5.</strong> Overview</a></li><li class="chapter-item expanded "><a href="benchmarks/library_benchmarks.html"><strong aria-hidden="true">6.</strong> Library Benchmarks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="benchmarks/library_benchmarks/important.html"><strong aria-hidden="true">6.1.</strong> Important default behaviour</a></li><li class="chapter-item expanded "><a href="benchmarks/library_benchmarks/quickstart.html"><strong aria-hidden="true">6.2.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href="benchmarks/library_benchmarks/structure.html"><strong aria-hidden="true">6.3.</strong> Structure of a library benchmark</a></li><li class="chapter-item expanded "><a href="benchmarks/library_benchmarks/macros.html"><strong aria-hidden="true">6.4.</strong> The macros in more detail</a></li><li class="chapter-item expanded "><a href="benchmarks/library_benchmarks/setup_and_teardown.html"><strong aria-hidden="true">6.5.</strong> setup and teardown</a></li><li class="chapter-item expanded "><a href="benchmarks/library_benchmarks/multiple_benches.html"><strong aria-hidden="true">6.6.</strong> Specify multiple benches at once</a></li><li class="chapter-item expanded "><a href="benchmarks/library_benchmarks/generic.html"><strong aria-hidden="true">6.7.</strong> Generic benchmark functions</a></li><li class="chapter-item expanded "><a href="benchmarks/library_benchmarks/compare_by_id.html"><strong aria-hidden="true">6.8.</strong> Comparing benchmark functions</a></li><li class="chapter-item expanded "><a href="benchmarks/library_benchmarks/configuration.html"><strong aria-hidden="true">6.9.</strong> Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="benchmarks/library_benchmarks/configuration/output_format.html"><strong aria-hidden="true">6.9.1.</strong> Output Format/Cache Misses</a></li></ol></li><li class="chapter-item expanded "><a href="benchmarks/library_benchmarks/custom_entry_point.html"><strong aria-hidden="true">6.10.</strong> Custom entry points</a></li><li class="chapter-item expanded "><a href="benchmarks/library_benchmarks/threads_and_subprocesses.html"><strong aria-hidden="true">6.11.</strong> Multi-threaded and multi-process applications</a></li><li class="chapter-item expanded "><a href="benchmarks/library_benchmarks/examples.html"><strong aria-hidden="true">6.12.</strong> More Examples, please!</a></li></ol></li><li class="chapter-item expanded "><a href="benchmarks/binary_benchmarks.html"><strong aria-hidden="true">7.</strong> Binary Benchmarks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="benchmarks/binary_benchmarks/important.html"><strong aria-hidden="true">7.1.</strong> Important default behaviour</a></li><li class="chapter-item expanded "><a href="benchmarks/binary_benchmarks/quickstart.html"><strong aria-hidden="true">7.2.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href="benchmarks/binary_benchmarks/differences.html"><strong aria-hidden="true">7.3.</strong> Differences to library benchmarks</a></li><li class="chapter-item expanded "><a href="benchmarks/binary_benchmarks/stdin_and_pipe.html"><strong aria-hidden="true">7.4.</strong> The Command's stdin and simulating piped input</a></li><li class="chapter-item expanded "><a href="benchmarks/binary_benchmarks/configuration.html"><strong aria-hidden="true">7.5.</strong> Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="benchmarks/binary_benchmarks/configuration/delay.html"><strong aria-hidden="true">7.5.1.</strong> Delay the Command</a></li><li class="chapter-item expanded "><a href="benchmarks/binary_benchmarks/configuration/sandbox.html"><strong aria-hidden="true">7.5.2.</strong> Sandbox</a></li><li class="chapter-item expanded "><a href="benchmarks/binary_benchmarks/configuration/exit_code.html"><strong aria-hidden="true">7.5.3.</strong> Configure the exit code of the Command</a></li></ol></li><li class="chapter-item expanded "><a href="benchmarks/binary_benchmarks/low_level.html"><strong aria-hidden="true">7.6.</strong> Low-level api</a></li><li class="chapter-item expanded "><a href="benchmarks/binary_benchmarks/examples.html"><strong aria-hidden="true">7.7.</strong> More examples needed?</a></li></ol></li><li class="chapter-item expanded "><a href="regressions.html"><strong aria-hidden="true">8.</strong> Detecting Performance Regressions</a></li><li class="chapter-item expanded "><a href="cachegrind.html"><strong aria-hidden="true">9.</strong> Cachegrind</a></li><li class="chapter-item expanded "><a href="dhat.html" class="active"><strong aria-hidden="true">10.</strong> Heap profiling with DHAT</a></li><li class="chapter-item expanded "><a href="tools.html"><strong aria-hidden="true">11.</strong> Other Valgrind Tools</a></li><li class="chapter-item expanded "><a href="client_requests.html"><strong aria-hidden="true">12.</strong> Valgrind Client Requests</a></li><li class="chapter-item expanded "><a href="flamegraphs.html"><strong aria-hidden="true">13.</strong> Callgrind Flamegraphs</a></li><li class="chapter-item expanded affix "><li class="part-title">Command-line and environment variables</li><li class="chapter-item expanded "><a href="cli_and_env/basics.html"><strong aria-hidden="true">14.</strong> Basic usage and exit codes</a></li><li class="chapter-item expanded "><a href="cli_and_env/baselines.html"><strong aria-hidden="true">15.</strong> Comparing with baselines</a></li><li class="chapter-item expanded "><a href="cli_and_env/output.html"><strong aria-hidden="true">16.</strong> Controlling the output of Iai-Callgrind</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cli_and_env/output/out_directory.html"><strong aria-hidden="true">16.1.</strong> Customize the output directory</a></li><li class="chapter-item expanded "><a href="cli_and_env/output/machine_readable.html"><strong aria-hidden="true">16.2.</strong> Machine-readable output</a></li><li class="chapter-item expanded "><a href="cli_and_env/output/terminal_output.html"><strong aria-hidden="true">16.3.</strong> Showing terminal output of benchmarks</a></li><li class="chapter-item expanded "><a href="cli_and_env/output/color.html"><strong aria-hidden="true">16.4.</strong> Changing the color output</a></li><li class="chapter-item expanded "><a href="cli_and_env/output/logging.html"><strong aria-hidden="true">16.5.</strong> Changing the logging output</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Troubleshooting</li><li class="chapter-item expanded "><a href="troubleshooting/im-getting-the-error-sentinel-not-found.html"><strong aria-hidden="true">17.</strong> I'm getting the error Sentinel ... not found</a></li><li class="chapter-item expanded "><a href="troubleshooting/running-cargo-bench-results-in-an-unrecognized-option-error.html"><strong aria-hidden="true">18.</strong> Running cargo bench results in an "Unrecognized Option" error</a></li><li class="chapter-item expanded affix "><li class="part-title">Comparison</li><li class="chapter-item expanded "><a href="comparison/criterion.html"><strong aria-hidden="true">19.</strong> Criterion</a></li><li class="chapter-item expanded "><a href="comparison/iai.html"><strong aria-hidden="true">20.</strong> Iai</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        <div class="dropdown">
                          <button onclick="versionDropdown()" class="icon-button version-dropdown-button" type="button">Version</button>
                          <div id="version-dropdown" class="version-dropdown-content">
                            <a href="../../latest/html/index.html">Latest</a>
                            <hr class="sidbar-spacer">
                            <script src="../../versions.js"></script>
                          </div>
                        </div>
                    </div>

                    <h1 class="menu-title">Iai-Callgrind Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/iai-callgrind/iai-callgrind" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/iai-callgrind/iai-callgrind/master/docs/src/dhat.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- markdownlint-disable MD041 MD033 -->
<h1 id="dhat-a-dynamic-heap-analysis-tool"><a class="header" href="#dhat-a-dynamic-heap-analysis-tool">DHAT: a dynamic heap analysis tool</a></h1>
<h2 id="intro-to-dhat"><a class="header" href="#intro-to-dhat">Intro to DHAT</a></h2>
<p>To fully understand DHAT please read the <a href="https://valgrind.org/docs/manual/dh-manual.html">Valgrind docs</a> of DHAT. Here's
just a short summary and quote from the docs:</p>
<blockquote>
<p>DHAT is primarily a tool for examining how programs use their heap
allocations. It tracks the allocated blocks, and inspects every memory access
to find which block, if any, it is to. It presents, on a program point basis,
information about these blocks such as sizes, lifetimes, numbers of reads and
writes, and read and write patterns.</p>
</blockquote>
<p>The rest of this chapter is dedicated to how DHAT is integrated into
Iai-Callgrind.</p>
<h2 id="the-dhat-modes"><a class="header" href="#the-dhat-modes">The DHAT modes</a></h2>
<p>Iai-Callgrind supports all three modes <code>heap</code> (the default), <code>copy</code> and <code>ad-hoc</code>
which can be changed on the <a href="./cli_and_env/basics.html">command-line</a> with
<code>--dhat-args=--mode=ad-hoc</code> or in the benchmark itself with <code>Dhat::args</code>. Note
that <code>ad-hoc</code> mode requires <a href="./client_requests.html">client requests</a> which have
prerequisites. If running the benchmarks in <code>ad-hoc</code> mode, it is highly
recommended to turn off the <code>EntryPoint</code> with <code>EntryPoint::None</code> (See next
section). However, DHAT is normally run in <code>heap</code> mode and it is assumed that
this is the mode used in the next sections.</p>
<h2 id="the-default-entry-point"><a class="header" href="#the-default-entry-point">The default entry point</a></h2>
<p>The DHAT default entry point <code>EntryPoint::Default</code> in library benchmarks behaves
similar to <a href="./benchmarks/library_benchmarks/custom_entry_point.html"><code>Callgrind's EntryPoint</code></a>. This
centers the collected metrics shown in the terminal output around the benchmark
function. The entry point is set to <code>EntryPoint::None</code> for binary benchmarks.
But, if necessary, the entry point can be turned off or customized in
<code>Dhat::entry_point</code>.</p>
<p>In contrast to callgrind's entry point, the DHAT default entry point <em>includes</em>
the metrics of <a href="./benchmarks/library_benchmarks/setup_and_teardown.html"><code>setup</code> and/or <code>teardown</code>
code</a> or anything
specified in the <code>args</code> parameter of the <code>#[bench]</code> or <code>#[benches]</code> attribute.
This is a limitation of DHAT and what is possible to reliably extract from the
output files. Callgrind has a command-line flag <code>--toggle-collect</code> to toggle
collection on and off. DHAT doesn't have such an option, and the sanitization of
metrics can only be realized afterwards based on the DHAT output files. However,
this works well enough to stabilize the metrics so they exclude the metrics of
Iai-Callgrind allocations (around 2000 - 2500 bytes) in the <code>main</code> function
needed to setup the benchmark.</p>
<p>Note that setting an entry point or <code>Dhat::frames</code> does not alter the dhat
output files in any way.</p>
<h2 id="usage-on-the-command-line"><a class="header" href="#usage-on-the-command-line">Usage on the command-line</a></h2>
<p>Running DHAT instead of or in addition to Callgrind is pretty straight-forward
and not different to any <a href="./tools.html">other tool</a>:</p>
<p>Either use <a href="./cli_and_env/basics.html">command-line arguments or environment
variables</a>: <code>--default-tool=dhat</code> or
<code>IAI_CALLGRIND_DEFAULT_TOOL=dhat</code> (replaces callgrind as default tool) or
<code>--tools=dhat</code> or <code>IAI_CALLGRIND_TOOLS=dhat</code> (runs DHAT in addition to the
default tool).</p>
<h2 id="usage-in-a-benchmark-and-a-small-example-analysis"><a class="header" href="#usage-in-a-benchmark-and-a-small-example-analysis">Usage in a benchmark and a small example analysis</a></h2>
<p>Running DHAT in addition to Callgrind can also be carried out in the benchmark
itself with the <code>Dhat</code> struct in <code>LibraryBenchmarkConfig::tool</code>. Here, globally
in the <code>main!</code> macro:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate iai_callgrind;
</span><span class="boring">mod my_lib { pub fn bubble_sort(_: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; { vec![] } }
</span>use iai_callgrind::{
    library_benchmark, library_benchmark_group, main, LibraryBenchmarkConfig,
    Dhat
};
use std::hint::black_box;

#[library_benchmark]
#[bench::worst_case_3(vec![3, 2, 1])]
fn bench_bubble_sort(array: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    black_box(my_lib::bubble_sort(array))
}

library_benchmark_group!(name = my_group; benchmarks = bench_bubble_sort);

<span class="boring">fn main() {
</span>main!(
    config = LibraryBenchmarkConfig::default()
        .tool(Dhat::default());
    library_benchmark_groups = my_group
);
<span class="boring">}</span></code></pre></pre>
<p>The above benchmark will produce the following metrics:</p>
<pre><code class="hljs"><span style="color:#0A0">lib_bench_dhat::my_group::bench_library</span> <span style="color:#0AA">worst_case_3</span><span style="color:#0AA">:</span><b><span style="color:#00A">vec! [3, 2, 1]</span></b>
<span style="color:#555">  </span><span style="color:#555">=======</span> CALLGRIND <span style="color:#555">====================================================================</span>
<span style="color:#555">  </span>Instructions:                          <b>83</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>L1 Hits:                              <b>110</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>LL Hits:                                <b>0</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>RAM Hits:                               <b>3</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>Total read+write:                     <b>113</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>Estimated Cycles:                     <b>215</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span><span style="color:#555">=======</span> DHAT <span style="color:#555">=========================================================================</span>
<span style="color:#555">  </span>Total bytes:                           <b>12</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>Total blocks:                           <b>1</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>At t-gmax bytes:                        <b>0</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>At t-gmax blocks:                       <b>0</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>At t-end bytes:                         <b>0</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>At t-end blocks:                        <b>0</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>Reads bytes:                           <b>24</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>Writes bytes:                          <b>36</b>|N/A                  (<span style="color:#555">*********</span>)

Iai-Callgrind result: <b><span style="color:#0A0">Ok</span></b>. 1 without regressions; 0 regressed; 1 benchmarks finished in 0.55554s</code></pre>
<p>Analyzing the DHAT data, there are a total of <code>12 bytes</code> of allocations (The
vector: <code>3 * sizeof(i32)</code> bytes = <code>3 * 4</code> bytes) in <code>1</code> block during the setup
of the benchmark. That's also <code>12</code> bytes of writes to fill the vector with the
values. That makes <code>24</code> bytes of reads and <code>24</code> bytes of writes in the
<code>bubble_sort</code> function. Also, there are no (de-)allocations of heap memory in
<code>bubble_sort</code> itself.</p>
<h2 id="soft-limits-and-hard-limits"><a class="header" href="#soft-limits-and-hard-limits">Soft limits and hard limits</a></h2>
<p>Based on that data, we could define for example hard limits (or soft limits or
both whatever you think is appropriate) to ensure <code>bubble_sort</code> is not getting
worse than that.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate iai_callgrind;
</span><span class="boring">mod my_lib { pub fn bubble_sort(_: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; { vec![] } }
</span>use iai_callgrind::{
    library_benchmark, library_benchmark_group, main, LibraryBenchmarkConfig,
    Dhat, DhatMetric
};
use std::hint::black_box;

#[library_benchmark]
#[bench::worst_case_3(
    args = (vec![3, 2, 1]),
    config = LibraryBenchmarkConfig::default()
        .tool(Dhat::default()
            .hard_limits([
                (DhatMetric::ReadsBytes, 24),
                (DhatMetric::WritesBytes, 32)
            ])
        )
)]
fn bench_bubble_sort(array: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    black_box(my_lib::bubble_sort(array))
}

library_benchmark_group!(name = my_group; benchmarks = bench_bubble_sort);

<span class="boring">fn main() {
</span>main!(
    config = LibraryBenchmarkConfig::default()
        .tool(Dhat::default());
    library_benchmark_groups = my_group
);
<span class="boring">}</span></code></pre></pre>
<p>Now, if <code>bubble_sort</code> would read more than <code>24</code> bytes or if there were more than
<code>32</code> bytes of writes during the benchmark, the benchmark would fail and exit
with error.</p>
<h2 id="frames-and-benchmarking-multi-threaded-functions"><a class="header" href="#frames-and-benchmarking-multi-threaded-functions">Frames and benchmarking multi-threaded functions</a></h2>
<p>It is possible to specify additional <code>Dhat::frames</code> for example when
benchmarking multi-threaded functions. Like in callgrind, each thread/subprocess
in DHAT is treated as a separate unit and thus requires <code>frames</code> (the
Iai-Callgrind specific approximation of callgrind toggles) in addition to the
default entry point to include the interesting ones in the measurements.</p>
<p>By example. Suppose there's a function in the <code>benchmark_tests</code> library
<code>find_primes_multi_thread(num_threads: usize)</code> which searches for primes in the
range <code>0</code> - <code>10000 * num_threads</code>. This multi-threaded function is splitting the
work for each <code>10000</code> numbers into a separate thread each calling the
single-threaded function <code>benchmark_tests::find_primes</code> which does the actual
work. The inner workings aren't important but this description should be enough
to understand the basic idea.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate iai_callgrind;
</span><span class="boring">mod benchmark_tests { pub fn find_primes_multi_thread (_: u64) -&gt; Vec&lt;u64&gt; { vec![] } }
</span>use std::hint::black_box;
use iai_callgrind::{
    library_benchmark, library_benchmark_group, main, LibraryBenchmarkConfig,
    ValgrindTool,
};

#[library_benchmark(
    config = LibraryBenchmarkConfig::default()
        .default_tool(ValgrindTool::DHAT)
)]
fn bench_library() -&gt; Vec&lt;u64&gt; {
    black_box(benchmark_tests::find_primes_multi_thread(black_box(1)))
}

library_benchmark_group!(name = my_group; benchmarks = bench_library);
<span class="boring">fn main() {
</span>main!(library_benchmark_groups = my_group);
<span class="boring">}</span></code></pre></pre>
<p>Running the benchmark produces the following output:</p>
<pre><code class="hljs"><span style="color:#0A0">lib_bench_find_primes::my_group::bench_library</span>
<span style="color:#555">  </span><span style="color:#555">=======</span> DHAT <span style="color:#555">=========================================================================</span>
<span style="color:#555">  </span>Total bytes:                        <b>11456</b>|11456                (<span style="color:#555">No change</span>)
<span style="color:#555">  </span>Total blocks:                           <b>9</b>|9                    (<span style="color:#555">No change</span>)
<span style="color:#555">  </span>At t-gmax bytes:                    <b>10264</b>|10264                (<span style="color:#555">No change</span>)
<span style="color:#555">  </span>At t-gmax blocks:                       <b>4</b>|4                    (<span style="color:#555">No change</span>)
<span style="color:#555">  </span>At t-end bytes:                         <b>0</b>|0                    (<span style="color:#555">No change</span>)
<span style="color:#555">  </span>At t-end blocks:                        <b>0</b>|0                    (<span style="color:#555">No change</span>)
<span style="color:#555">  </span>Reads bytes:                          <b>776</b>|776                  (<span style="color:#555">No change</span>)
<span style="color:#555">  </span>Writes bytes:                       <b>10329</b>|10329                (<span style="color:#555">No change</span>)

Iai-Callgrind result: <b><span style="color:#0A0">Ok</span></b>. 1 without regressions; 0 regressed; 1 benchmarks finished in 0.44534s</code></pre>
<p>The problem here is, that the spawned thread is not included in the metrics.
Looking at the output files of the dhat output in <code>dh_view.html</code> (heavily
shortened to safe some space):</p>
<pre><code class="language-text">Invocation {
  Mode:    heap
  Command: /home/some/project/target/release/deps/lib_bench_find_primes-c304b7c3fed25785 --iai-run my_group 0 0 lib_bench_find_primes::my_group::bench_library
  PID:     212817
}

Times {
  t-gmax: 2,825,042 instrs (99.57% of program duration)
  t-end:  2,837,309 instrs
}

▼ PP 1/1 (3 children) {
    Total:     46,827 bytes (100%, 16,504.02/Minstr) in 37 blocks (100%, 13.04/Minstr), avg size 1,265.59 bytes, avg lifetime 840,789.86 instrs (29.63% of program duration)
    At t-gmax: 26,847 bytes (100%) in 9 blocks (100%), avg size 2,983 bytes
    At t-end:  0 bytes (0%) in 0 blocks (0%), avg size 0 bytes
    Reads:     45,876 bytes (100%, 16,168.84/Minstr), 0.98/byte
    Writes:    48,285 bytes (100%, 17,017.89/Minstr), 1.03/byte
    Allocated at {
      #0: [root]
    }
  }
  ├─▼ PP 1.1/3 (12 children) {
  │     Total:     46,027 bytes (98.29%, 16,222.06/Minstr) in 28 blocks (75.68%, 9.87/Minstr), avg size 1,643.82 bytes, avg lifetime 858,562.71 instrs (30.26% of program duration)
  │     At t-gmax: 26,511 bytes (98.75%) in 7 blocks (77.78%), avg size 3,787.29 bytes
  │     At t-end:  0 bytes (0%) in 0 blocks (0%), avg size 0 bytes
  │     Reads:     45,412 bytes (98.99%, 16,005.31/Minstr), 0.99/byte
  │     Writes:    47,925 bytes (99.25%, 16,891/Minstr), 1.04/byte
  │     Allocated at {
  │       #1: 0x48C57A8: malloc (in /usr/lib/valgrind/vgpreload_dhat-amd64-linux.so)
  │     }
  │   }
  │   ├── PP 1.1.1/12 {
  │   │     Total:     32,736 bytes (69.91%, 11,537.69/Minstr) in 10 blocks (27.03%, 3.52/Minstr), avg size 3,273.6 bytes, avg lifetime 235,111.9 instrs (8.29% of program duration)
  │   │     Max:       16,384 bytes in 1 blocks, avg size 16,384 bytes
  │   │     At t-gmax: 16,384 bytes (61.03%) in 1 blocks (11.11%), avg size 16,384 bytes
  │   │     At t-end:  0 bytes (0%) in 0 blocks (0%), avg size 0 bytes
  │   │     Reads:     26,184 bytes (57.08%, 9,228.46/Minstr), 0.8/byte
  │   │     Writes:    26,184 bytes (54.23%, 9,228.46/Minstr), 0.8/byte
  │   │     Allocated at {
  │   │       ^1: 0x48C57A8: malloc (in /usr/lib/valgrind/vgpreload_dhat-amd64-linux.so)
  │   │       #2: 0x40153B7: UnknownInlinedFun (alloc.rs:93)
  │   │       #3: 0x40153B7: UnknownInlinedFun (alloc.rs:188)
  │   │       #4: 0x40153B7: UnknownInlinedFun (alloc.rs:249)
  │   │       #5: 0x40153B7: UnknownInlinedFun (mod.rs:476)
  │   │       #6: 0x40153B7: with_capacity_in&lt;alloc::alloc::Global&gt; (mod.rs:422)
  │   │       #7: 0x40153B7: with_capacity_in&lt;u64, alloc::alloc::Global&gt; (mod.rs:190)
  │   │       #8: 0x40153B7: with_capacity_in&lt;u64, alloc::alloc::Global&gt; (mod.rs:815)
  │   │       #9: 0x40153B7: with_capacity&lt;u64&gt; (mod.rs:495)
  │   │       #10: 0x40153B7: from_iter&lt;u64, core::iter::adapters::filter::Filter&lt;core::ops::range::RangeInclusive&lt;u64&gt;, benchmark_tests::find_primes::{closure_env#0}&gt;&gt; (spec_from_iter_nested.rs:31)
  │   │       #11: 0x40153B7: &lt;alloc::vec::Vec&lt;T&gt; as alloc::vec::spec_from_iter::SpecFromIter&lt;T,I&gt;&gt;::from_iter (spec_from_iter.rs:34)
  │   │       #12: 0x4013B67: from_iter&lt;u64, core::iter::adapters::filter::Filter&lt;core::ops::range::RangeInclusive&lt;u64&gt;, benchmark_tests::find_primes::{closure_env#0}&gt;&gt; (mod.rs:3438)
  │   │       #13: 0x4013B67: collect&lt;core::iter::adapters::filter::Filter&lt;core::ops::range::RangeInclusive&lt;u64&gt;, benchmark_tests::find_primes::{closure_env#0}&gt;, alloc::vec::Vec&lt;u64, alloc::alloc::Global&gt;&gt; (iterator.rs:2001)
  │   │       #14: 0x4013B67: benchmark_tests::find_primes (lib.rs:25)
  │   │       #15: 0x4015800: {closure#0} (lib.rs:32)
  │   │       #16: 0x4015800: std::sys::backtrace::__rust_begin_short_backtrace (backtrace.rs:152)
  │   │       #17: 0x4014824: {closure#0}&lt;benchmark_tests::find_primes_multi_thread::{closure_env#0}, alloc::vec::Vec&lt;u64, alloc::alloc::Global&gt;&gt; (mod.rs:559)
  │   │       #18: 0x4014824: call_once&lt;alloc::vec::Vec&lt;u64, alloc::alloc::Global&gt;, std::thread::{impl#0}::spawn_unchecked_::{closure#1}::{closure_env#0}&lt;benchmark_tests::find_primes_multi_thread::{closure_env#0}, alloc::vec::Vec&lt;u64, alloc::alloc::Global&gt;&gt;&gt; (unwind_safe.rs:272)
  │   │       #19: 0x4014824: do_call&lt;core::panic::unwind_safe::AssertUnwindSafe&lt;std::thread::{impl#0}::spawn_unchecked_::{closure#1}::{closure_env#0}&lt;benchmark_tests::find_primes_multi_thread::{closure_env#0}, alloc::vec::Vec&lt;u64, alloc::alloc::Global&gt;&gt;&gt;, alloc::vec::Vec&lt;u64, alloc::alloc::Global&gt;&gt; (panicking.rs:589)
  │   │       #20: 0x4014824: try&lt;alloc::vec::Vec&lt;u64, alloc::alloc::Global&gt;, core::panic::unwind_safe::AssertUnwindSafe&lt;std::thread::{impl#0}::spawn_unchecked_::{closure#1}::{closure_env#0}&lt;benchmark_tests::find_primes_multi_thread::{closure_env#0}, alloc::vec::Vec&lt;u64, alloc::alloc::Global&gt;&gt;&gt;&gt; (panicking.rs:552)
  │   │       #21: 0x4014824: catch_unwind&lt;core::panic::unwind_safe::AssertUnwindSafe&lt;std::thread::{impl#0}::spawn_unchecked_::{closure#1}::{closure_env#0}&lt;benchmark_tests::find_primes_multi_thread::{closure_env#0}, alloc::vec::Vec&lt;u64, alloc::alloc::Global&gt;&gt;&gt;, alloc::vec::Vec&lt;u64, alloc::alloc::Global&gt;&gt; (panic.rs:359)
  │   │       #22: 0x4014824: {closure#1}&lt;benchmark_tests::find_primes_multi_thread::{closure_env#0}, alloc::vec::Vec&lt;u64, alloc::alloc::Global&gt;&gt; (mod.rs:557)
  │   │       #23: 0x4014824: core::ops::function::FnOnce::call_once{{vtable.shim}} (function.rs:250)
  │   │       #24: 0x404460A: call_once&lt;(), dyn core::ops::function::FnOnce&lt;(), Output=()&gt;, alloc::alloc::Global&gt; (boxed.rs:1966)
  │   │       #25: 0x404460A: call_once&lt;(), alloc::boxed::Box&lt;dyn core::ops::function::FnOnce&lt;(), Output=()&gt;, alloc::alloc::Global&gt;, alloc::alloc::Global&gt; (boxed.rs:1966)
  │   │       #26: 0x404460A: std::sys::pal::unix::thread::Thread::new::thread_start (thread.rs:97)
  │   │       #27: 0x49BB7EA: ??? (in /usr/lib/libc.so.6)
  │   │       #28: 0x4A3EFB3: clone (in /usr/lib/libc.so.6)
  │   │     }
  │   │   }
  ...
</code></pre>
<p>The missing metrics of the thread are caused by the default entry point which
only includes the program points with the benchmark function in their call
stack. But, looking closely at the program point <code>PP 1.1.1/12</code> and the call
stack, there's no frame (function call) of the benchmark function
<code>bench_library</code> or a <code>main</code> function. As mentioned earlier, this is because the
thread is completely separated by DHAT.</p>
<p>There are multiple ways to go on depending on what we want to measure. To show
two different approaches, at first, I'll go with measuring the benchmark
function with the function spawning the threads (the default entry point which
doesn't have to be specified) and additionally all threads which execute the
<code>benchmark_tests::find_primes</code> function.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate iai_callgrind;
</span><span class="boring">mod benchmark_tests { pub fn find_primes_multi_thread (_: u64) -&gt; Vec&lt;u64&gt; { vec![] } }
</span>use std::hint::black_box;
use iai_callgrind::{
    library_benchmark, library_benchmark_group, main, LibraryBenchmarkConfig,
    ValgrindTool, Dhat
};

#[library_benchmark(
    config = LibraryBenchmarkConfig::default()
        .default_tool(ValgrindTool::DHAT)
        .tool(Dhat::default()
            .frames(["benchmark_tests::find_primes"])
        )
)]
fn bench_library() -&gt; Vec&lt;u64&gt; {
    black_box(benchmark_tests::find_primes_multi_thread(black_box(1)))
}

library_benchmark_group!(name = my_group; benchmarks = bench_library);
<span class="boring">fn main() {
</span>main!(library_benchmark_groups = my_group);
<span class="boring">}</span></code></pre></pre>
<p>Now, the metrics include the spawned thread(s):</p>
<pre><code class="hljs"><span style="color:#0A0">lib_bench_find_primes::my_group::bench_library</span>
<span style="color:#555">  </span><span style="color:#555">=======</span> DHAT <span style="color:#555">=========================================================================</span>
<span style="color:#555">  </span>Total bytes:                        <b>44192</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>Total blocks:                          <b>19</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>At t-gmax bytes:                    <b>26648</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>At t-gmax blocks:                       <b>5</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>At t-end bytes:                         <b>0</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>At t-end blocks:                        <b>0</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>Reads bytes:                        <b>26960</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>Writes bytes:                       <b>36513</b>|N/A                  (<span style="color:#555">*********</span>)

Iai-Callgrind result: <b><span style="color:#0A0">Ok</span></b>. 1 without regressions; 0 regressed; 1 benchmarks finished in 0.44273s</code></pre>
<p>If we were only interested in the threads itself, then using
<code>EntryPoint::Custom</code> would be one way to do it. Setting a custom entry point is
sugar for disabling the entry point with <code>EntryPoint::None</code> and specifying a
frame with <code>Dhat::frames</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate iai_callgrind;
</span><span class="boring">mod benchmark_tests { pub fn find_primes_multi_thread (_: u64) -&gt; Vec&lt;u64&gt; { vec![] } }
</span>use std::hint::black_box;
use iai_callgrind::{
    library_benchmark, library_benchmark_group, main, LibraryBenchmarkConfig,
    ValgrindTool, Dhat, EntryPoint
};

#[library_benchmark(
    config = LibraryBenchmarkConfig::default()
        .default_tool(ValgrindTool::DHAT)
        .tool(Dhat::default()
            .entry_point(
                EntryPoint::Custom("benchmark_tests::find_primes".to_owned())
            )
        )
)]
fn bench_library() -&gt; Vec&lt;u64&gt; {
    black_box(benchmark_tests::find_primes_multi_thread(black_box(1)))
}

library_benchmark_group!(name = my_group; benchmarks = bench_library);
<span class="boring">fn main() {
</span>main!(library_benchmark_groups = my_group);
<span class="boring">}</span></code></pre></pre>
<p>Running this benchmark results in:</p>
<pre><code class="hljs"><span style="color:#0A0">lib_bench_find_primes::my_group::bench_library</span>
<span style="color:#555">  </span><span style="color:#555">=======</span> DHAT <span style="color:#555">=========================================================================</span>
<span style="color:#555">  </span>Total bytes:                        <b>32736</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>Total blocks:                          <b>10</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>At t-gmax bytes:                    <b>16384</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>At t-gmax blocks:                       <b>1</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>At t-end bytes:                         <b>0</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>At t-end blocks:                        <b>0</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>Reads bytes:                        <b>26184</b>|N/A                  (<span style="color:#555">*********</span>)
<span style="color:#555">  </span>Writes bytes:                       <b>26184</b>|N/A                  (<span style="color:#555">*********</span>)

Iai-Callgrind result: <b><span style="color:#0A0">Ok</span></b>. 1 without regressions; 0 regressed; 1 benchmarks finished in 0.45178s</code></pre>
<p>To verify our setup, let's compare these numbers with the data of the program
point with the thread of the <code>dh_view.html</code> output shown above. Eventually,
these are the same metrics:</p>
<pre><code class="language-text">  │   ├── PP 1.1.1/12 {
  │   │     Total:     32,736 bytes (69.91%, 11,537.69/Minstr) in 10 blocks (27.03%, 3.52/Minstr), avg size 3,273.6 bytes, avg lifetime 235,111.9 instrs (8.29% of program duration)
  │   │     Max:       16,384 bytes in 1 blocks, avg size 16,384 bytes
  │   │     At t-gmax: 16,384 bytes (61.03%) in 1 blocks (11.11%), avg size 16,384 bytes
  │   │     At t-end:  0 bytes (0%) in 0 blocks (0%), avg size 0 bytes
  │   │     Reads:     26,184 bytes (57.08%, 9,228.46/Minstr), 0.8/byte
  │   │     Writes:    26,184 bytes (54.23%, 9,228.46/Minstr), 0.8/byte
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="cachegrind.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="tools.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="cachegrind.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="tools.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="js/dropdown.js"></script>


    </div>
    </body>
</html>
